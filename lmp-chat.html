<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

<!--
The project default title is "Peach Portal," named after my ongoing LLLM project, Peach.
Change it to whatever you like, obviously.
-->

    <title>Peach Portal</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 flex items-center justify-center h-screen">
    <div class="bg-white p-6 rounded-lg shadow-lg w-full max-w-5xl">

<!--
  The default message window label is "The Peach Portal" and a version number based on my internal development history.
  Change it to whatever you like, obviously.
-->
        <h2 class="text-2xl font-bold mb-4 text-center">The Peach Portal v1.2</h2>

<!--
  Put the IP address and port of the LM studio server here. Can change at will. Default port for LM Studio to listen on
  really is 1234. Somebody had to have it!
--> 

        <div class="mb-4 flex items-center space-x-2">
            <label for="server-url" class="text-sm font-medium text-gray-700">Server URL:</label>
            <input
                id="server-url"
                type="text"
                placeholder="e.g., http://168.0.0.123:1234"
                class="flex-1 p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                value="http://168.0.0.123:1234"
            />
            <button
                id="save-url-button"
                class="bg-blue-500 text-white px-3 py-1 rounded-lg hover:bg-blue-600"
            >
                Save
            </button>
        </div>

<!--
  All chats must have a unique chat identifier. As noted they can be renamed from default when initialized or any time after.
  "Fork Chat" will create an exact duplicate of the current chat with a default fork name value. This allows you to
  "save" a chat and try different prompts without losing the main/current storyline. Chats are stored locally and don't take
  up that much space, but you can delete the current chat at will with the Delete Chat button.
--> 

        <div class="flex justify-between mb-4">

            <select id="chat-history-select" class="p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                <option value="">Select Chat History</option>
            </select>
            <div>
                <button id="new-chat-button" class="bg-green-500 text-white px-3 py-1 rounded-lg hover:bg-green-600 mr-2">New Chat</button>
                <button id="rename-chat-button" class="bg-yellow-500 text-white px-3 py-1 rounded-lg hover:bg-yellow-600 mr-2">Rename Chat</button>
                <button id="fork-chat-button" class="bg-teal-500 text-white px-3 py-1 rounded-lg hover:bg-teal-600 mr-2">Fork Chat</button>
                <button id="delete-chat-button" class="bg-red-500 text-white px-3 py-1 rounded-lg hover:bg-red-600">Delete Chat</button>
            </div>
        </div>

<!--
The default message window label is "The Peach Portal" and a version number based on my internal development history.
Change it to whatever you like, obviously.
-->

        <div class="mb-4 flex items-center space-x-2">
            <select id="model-select" class="w-1/2 p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                <option value="">Select Model</option>
            </select>
            <button id="retry-models-button" class="bg-gray-500 text-white px-3 py-1 rounded-lg hover:bg-gray-600 hidden">Retry</button>
            <button id="set-prompt-button" class="bg-purple-500 text-white px-3 py-1 rounded-lg hover:bg-purple-600">Set System Prompt</button>
            <button id="see-prompt-button" class="bg-green-600 text-white px-3 py-1 rounded-lg hover:bg-green-700">See System Prompt</button>
        </div>

<!--
  All chats must have a unique chat identifier. As noted they can be renamed from default when initialized or any time after.
  "Fork Chat" will create an exact duplicate of the current chat with a default fork name value. This allows you to
  "save" a chat and try different prompts without losing the main/current storyline. Chats are stored locally and don't take
  up that much space, but you can delete the current chat at will with the Delete Chat button.
--> 

        <div class="mb-4 flex items-center space-x-2">
            <label for="max-tokens-select" class="text-sm font-medium text-gray-700">Max Tokens:</label>
            <select id="max-tokens-select" class="w-1/4 p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                <option value="128">128</option>
                <option value="256">256</option>
                <option value="512">512</option>
                <option value="1024" selected>1024</option>
                <option value="2048">2048</option>
                <option value="4096">4096</option>
                <option value="8192">8192</option>
            </select>

<!--
  This dropdown allows you to select a temperature value. You can replace it with a direct input if you want but you will need to sanitize it
  or users will screw things up by putting in wacky values. This parameter controls how closely the LLM sticks to the input message language.
  The higher the value the more randomness it will use to generate the output.
--> 

            <label for="temperature-select" class="text-sm font-medium text-gray-700">Temperature:</label>
            <select id="temperature-select" class="w-1/4 p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                <option value="0.1">0.1</option>
                <option value="0.2">0.2</option>
                <option value="0.3">0.3</option>
                <option value="0.4">0.4</option>
                <option value="0.5">0.5</option>
                <option value="0.6" selected>0.6</option>
                <option value="0.7">0.7</option>
                <option value="0.8">0.8</option>
                <option value="0.9">0.9</option>
            </select>

<!--
  This dropdown allows you to select a top-p value. You can replace it with a direct input if you want but you will need to sanitize it
  or users will screw things up by putting in wacky values.This parameter controls how broadly the LLM searches probability space to locate
  approproiate response tokens. The smaller the value the more constrained the search.
--> 

            <label for="top-p-select" class="text-sm font-medium text-gray-700">Top P:</label>
            <select id="top-p-select" class="w-1/4 p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                <option value="0.1">0.1</option>
                <option value="0.2">0.2</option>
                <option value="0.3">0.3</option>
                <option value="0.4">0.4</option>
                <option value="0.5">0.5</option>
                <option value="0.6">0.6</option>
                <option value="0.7">0.7</option>
                <option value="0.8">0.8</option>
                <option value="0.9" selected>0.9</option>
            </select>
        </div>

<!--
  This is configured so that shift-Return makes a new line (only for human convenience, most LLM ignore newline characters in prompts)
  and either Return or clicking the "Send" button sends the message to the LLM. An "Edit" button appears next to the last user prompt message
  in the main chat window. This in combinaton with the regenerate button allows do-overs if you want to try to improve a prompt.
--> 

        <div id="chat-container" class="h-[32rem] overflow-y-auto mb-4 p-4 border rounded-lg bg-gray-50"></div>
        <div class="flex space-x-2">
            <textarea
                id="user-input"
                placeholder="Type your message..."
                class="flex-1 p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 h-20 resize-y"
            ></textarea>
            <div class="flex flex-col space-y-2">
                <button
                    id="send-button"
                    class="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600"
                    onclick="sendMessage()"
                >
                    Send
                </button>

<!--
  The Regenerate Last Response button is visible only when the last message in the main chat window was created by the LLM. It deletes the 
  last message the LLM sent and resends the last user prompt message to get a new response message.
--> 

                <button
                    id="regenerate-button"
                    class="bg-orange-500 text-white px-4 py-2 rounded-lg hover:bg-orange-600 hidden"
                >
                    Regenerate Last Response
                </button>
            </div>
        </div>
    </div>

    <!-- System Prompt Modal -->

<!--
  Allows you to set a new System prmopt. It does NOT show the old one, use Show Prompt for that.
--> 

    <div id="prompt-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center hidden">
        <div class="bg-white p-6 rounded-lg shadow-lg w-full max-w-md">
            <h2 class="text-xl font-bold mb-4">Set System Prompt</h2>
            <textarea
                id="system-prompt-input"
                class="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 h-32 resize-y"
                placeholder="Enter system prompt (e.g., 'You are a helpful assistant.')"
            ></textarea>
            <div class="flex justify-end space-x-2 mt-4">
                <button id="save-prompt-button" class="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600">Save</button>
                <button id="cancel-prompt-button" class="bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600">Cancel</button>
            </div>
        </div>
    </div>

    <!-- See System Prompt Modal -->

<!--
  Allows you to see but not edit the current system prompt.
--> 

    <div id="see-prompt-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center hidden">
        <div class="bg-white p-6 rounded-lg shadow-lg w-full max-w-md">
            <h2 class="text-xl font-bold mb-4">Current System Prompt</h2>
            <p id="current-prompt-display" class="w-full p-2 border rounded-lg bg-gray-50 h-32 overflow-y-auto"></p>
            <div class="flex justify-end mt-4">
                <button id="close-prompt-button" class="bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600">Close</button>
            </div>
        </div>
    </div>

    <!-- Edit Message Modal -->

<!--
  This aLLows the user to edit their last prompt message.
--> 

    <div id="edit-message-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center hidden">
        <div class="bg-white p-6 rounded-lg shadow-lg w-full max-w-md">
            <h2 class="text-xl font-bold mb-4">Edit Message</h2>
            <textarea
                id="edit-message-input"
                class="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 h-32 resize-y"
            ></textarea>
            <div class="flex justify-end space-x-2 mt-4">
                <button id="save-message-button" class="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600">Save</button>
                <button id="cancel-message-button" class="bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        const chatContainer = document.getElementById('chat-container');
        const userInput = document.getElementById('user-input');
        const chatHistorySelect = document.getElementById('chat-history-select');
        const newChatButton = document.getElementById('new-chat-button');
        const renameChatButton = document.getElementById('rename-chat-button');
        const forkChatButton = document.getElementById('fork-chat-button');
        const deleteChatButton = document.getElementById('delete-chat-button');
        const modelSelect = document.getElementById('model-select');
        const retryModelsButton = document.getElementById('retry-models-button');
        const maxTokensSelect = document.getElementById('max-tokens-select');
        const temperatureSelect = document.getElementById('temperature-select');
        const topPSelect = document.getElementById('top-p-select');
        const serverUrlInput = document.getElementById('server-url');
        const saveUrlButton = document.getElementById('save-url-button');
        const setPromptButton = document.getElementById('set-prompt-button');
        const seePromptButton = document.getElementById('see-prompt-button');
        const promptModal = document.getElementById('prompt-modal');
        const systemPromptInput = document.getElementById('system-prompt-input');
        const savePromptButton = document.getElementById('save-prompt-button');
        const cancelPromptButton = document.getElementById('cancel-prompt-button');
        const seePromptModal = document.getElementById('see-prompt-modal');
        const currentPromptDisplay = document.getElementById('current-prompt-display');
        const closePromptButton = document.getElementById('close-prompt-button');
        const editMessageModal = document.getElementById('edit-message-modal');
        const editMessageInput = document.getElementById('edit-message-input');
        const saveMessageButton = document.getElementById('save-message-button');
        const cancelMessageButton = document.getElementById('cancel-message-button');
        const regenerateButton = document.getElementById('regenerate-button');

        // Load saved server URL from localStorage or use default
        let apiBaseUrl = localStorage.getItem('lmStudioServerUrl') || 'http://10.0.0.59:1234/v1';
        let modelsUrl = `${apiBaseUrl}/models`;
        let chatUrl = `${apiBaseUrl}/chat/completions`;

        // Set initial server URL in input field
        serverUrlInput.value = apiBaseUrl.replace('/v1', '');

        let currentChatId = null;
        let lastUserMessage = null;

        // Generate a unique ID for chat histories
        function generateId() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Validate URL format
        function isValidUrl(url) {
            try {
                new URL(url);
                return true;
            } catch {
                return false;
            }
        }

        // Update API URLs based on user input
        function updateApiUrls() {
            let newUrl = serverUrlInput.value.trim();
            if (!newUrl) {
                alert('Please enter a server URL.');
                return;
            }
            if (!newUrl.endsWith('/v1')) {
                newUrl = newUrl.replace(/\/+$/, '') + '/v1';
            }
            if (!isValidUrl(newUrl)) {
                alert('Invalid URL format. Please enter a valid URL (e.g., http://10.0.0.59:1234).');
                return;
            }
            apiBaseUrl = newUrl;
            modelsUrl = `${apiBaseUrl}/models`;
            chatUrl = `${apiBaseUrl}/chat/completions`;
            localStorage.setItem('lmStudioServerUrl', apiBaseUrl);
            loadModels();
        }

        // Load system prompt for the selected model
        function loadSystemPrompt() {
            if (!modelSelect.value) return '';
            const prompts = JSON.parse(localStorage.getItem('systemPrompts') || '{}');
            return prompts[modelSelect.value] || '';
        }

        // Save system prompt for the selected model
        function saveSystemPrompt() {
            if (!modelSelect.value) {
                alert('Please select a model first.');
                return;
            }
            const prompt = systemPromptInput.value.trim();
            const prompts = JSON.parse(localStorage.getItem('systemPrompts') || '{}');
            prompts[modelSelect.value] = prompt;
            localStorage.setItem('systemPrompts', JSON.stringify(prompts));
            promptModal.classList.add('hidden');
        }

        // Show system prompt
        function showSystemPrompt() {
            if (!modelSelect.value) {
                alert('Please select a model first.');
                return;
            }
            const prompt = loadSystemPrompt();
            currentPromptDisplay.textContent = prompt || 'No system prompt set for this model.';
            seePromptModal.classList.remove('hidden');
        }

        // Rename chat
        function renameChat() {
            if (!currentChatId) {
                alert('Please select a chat to rename.');
                return;
            }
            const histories = JSON.parse(localStorage.getItem('chatHistories') || '{}');
            const currentName = histories[currentChatId].name || `Chat ${currentChatId.slice(0, 8)}`;
            const newName = prompt('Enter new name for the chat:', currentName);
            if (newName && newName.trim()) {
                histories[currentChatId].name = newName.trim();
                localStorage.setItem('chatHistories', JSON.stringify(histories));
                loadChatHistories();
                chatHistorySelect.value = currentChatId;
            }
        }

        // Fork chat
        function forkChat() {
            if (!currentChatId) {
                alert('Please select a chat to fork.');
                return;
            }
            const histories = JSON.parse(localStorage.getItem('chatHistories') || '{}');
            const currentChat = histories[currentChatId];
            const newId = generateId();
            let newName = prompt('Enter name for the forked chat (leave blank for auto-generated name):', `${currentChat.name || 'Chat ' + currentChatId.slice(0, 8)} Fork 1`);
            if (!newName) {
                let forkNumber = 1;
                const baseName = currentChat.name || `Chat ${currentChatId.slice(0, 8)}`;
                newName = `${baseName} Fork ${forkNumber}`;
                while (Object.values(histories).some(chat => chat.name === newName)) {
                    forkNumber++;
                    newName = `${baseName} Fork ${forkNumber}`;
                }
            }
            histories[newId] = {
                name: newName.trim(),
                messages: [...currentChat.messages]
            };
            localStorage.setItem('chatHistories', JSON.stringify(histories));
            loadChatHistories();
            loadChatHistory(newId);
        }

        // Load available models from LM Studio
        async function loadModels() {
            try {
                const response = await fetch(modelsUrl);
                if (!response.ok) {
                    throw new Error(`Failed to fetch models from ${modelsUrl}: ${response.statusText}`);
                }
                const data = await response.json();
                modelSelect.innerHTML = '<option value="">Select Model</option>';
                if (!data.data || data.data.length === 0) {
                    modelSelect.innerHTML = '<option value="">No models available</option>';
                    retryModelsButton.classList.remove('hidden');
                    return;
                }
                data.data.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.id;
                    option.textContent = model.id;
                    modelSelect.appendChild(option);
                });
                retryModelsButton.classList.add('hidden');
            } catch (error) {
                console.error('Error loading models:', error);
                modelSelect.innerHTML = `<option value="">Error: ${error.message}</option>`;
                retryModelsButton.classList.remove('hidden');
            }
        }

        // Load chat histories from localStorage
        function loadChatHistories() {
            const histories = JSON.parse(localStorage.getItem('chatHistories') || '{}');
            chatHistorySelect.innerHTML = '<option value="">Select Chat History</option>';
            Object.keys(histories).forEach(id => {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = histories[id].name || `Chat ${id.slice(0, 8)}`;
                chatHistorySelect.appendChild(option);
            });
        }

        // Save chat history to localStorage
        function saveChatHistory(id, name, messages) {
            const histories = JSON.parse(localStorage.getItem('chatHistories') || '{}');
            histories[id] = { name, messages };
            localStorage.setItem('chatHistories', JSON.stringify(histories));
        }

        // Load a specific chat history
        function loadChatHistory(id) {
            const histories = JSON.parse(localStorage.getItem('chatHistories') || '{}');
            if (histories[id]) {
                currentChatId = id;
                chatContainer.innerHTML = '';
                histories[id].messages.forEach((msg, index) => {
                    appendMessage(msg.sender, msg.content, msg.sender === 'You' ? 'text-blue-600' : 'text-gray-800', index);
                });
                chatHistorySelect.value = id;
                updateRegenerateButton();
            }
        }

        // Create a new chat
        function startNewChat() {
            const id = generateId();
            const name = prompt('Enter a name for the new chat:', `Chat ${new Date().toLocaleString()}`);
            if (name) {
                saveChatHistory(id, name, []);
                loadChatHistories();
                loadChatHistory(id);
            }
        }

        // Delete a chat history
        function deleteChatHistory() {
            if (!currentChatId) {
                alert('Select a chat to delete.');
                return;
            }
            if (confirm('Are you sure you want to delete this chat?')) {
                const histories = JSON.parse(localStorage.getItem('chatHistories') || '{}');
                delete histories[currentChatId];
                localStorage.setItem('chatHistories', JSON.stringify(histories));
                currentChatId = null;
                chatContainer.innerHTML = '';
                loadChatHistories();
                chatHistorySelect.value = '';
                regenerateButton.classList.add('hidden');
            }
        }

        // Append message to chat container and save to history
        function appendMessage(sender, message, colorClass, index = null) {
            const messageElement = document.createElement('div');
            messageElement.className = `mb-2 ${colorClass}`;
            const displaySender = sender === 'Bot' ? modelSelect.value : sender;
            messageElement.innerHTML = `<strong>${displaySender}:</strong><br>${message.replace(/\n/g, '<br>')}`;
            if (sender === 'You' && index !== null) {
                const editButton = document.createElement('button');
                editButton.className = 'ml-2 text-sm text-blue-500 hover:text-blue-700';
                editButton.textContent = 'Edit';
                editButton.dataset.index = index;
                editButton.addEventListener('click', () => openEditMessageModal(index));
                messageElement.appendChild(editButton);

                const deleteButton = document.createElement('button');
                deleteButton.className = 'ml-2 text-sm text-red-500 hover:text-red-700';
                deleteButton.textContent = 'Delete';
                deleteButton.dataset.index = index;
                deleteButton.addEventListener('click', () => deleteMessage(index));
                messageElement.appendChild(deleteButton);
            }
            chatContainer.appendChild(messageElement);
            chatContainer.scrollTop = chatContainer.scrollHeight;

            if (currentChatId && index === null) {
                const histories = JSON.parse(localStorage.getItem('chatHistories') || '{}');
                histories[currentChatId].messages.push({ sender, content: message });
                localStorage.setItem('chatHistories', JSON.stringify(histories));
            }
            updateRegenerateButton();
        }

        // Open edit message modal
        function openEditMessageModal(index) {
            const histories = JSON.parse(localStorage.getItem('chatHistories') || '{}');
            const message = histories[currentChatId].messages[index];
            if (message.sender !== 'You') return;
            editMessageInput.value = message.content;
            editMessageInput.dataset.index = index;
            editMessageModal.classList.remove('hidden');
        }

        // Save edited message
        function saveEditedMessage() {
            const index = parseInt(editMessageInput.dataset.index);
            const newContent = editMessageInput.value.trim();
            if (!newContent) {
                alert('Message cannot be empty.');
                return;
            }
            const histories = JSON.parse(localStorage.getItem('chatHistories') || '{}');
            histories[currentChatId].messages[index].content = newContent;
            localStorage.setItem('chatHistories', JSON.stringify(histories));
            loadChatHistory(currentChatId);
            editMessageModal.classList.add('hidden');
        }

        // Delete message and downstream messages
        function deleteMessage(index) {
            if (!confirm('Are you sure you want to delete this message and all subsequent messages?')) return;
            const histories = JSON.parse(localStorage.getItem('chatHistories') || '{}');
            histories[currentChatId].messages = histories[currentChatId].messages.slice(0, index);
            localStorage.setItem('chatHistories', JSON.stringify(histories));
            loadChatHistory(currentChatId);
        }

        // Update visibility of regenerate button
        function updateRegenerateButton() {
            const histories = JSON.parse(localStorage.getItem('chatHistories') || '{}');
            if (currentChatId && histories[currentChatId]) {
                const messages = histories[currentChatId].messages;
                const lastMessage = messages[messages.length - 1];
                if (lastMessage && lastMessage.sender === 'Bot') {
                    regenerateButton.classList.remove('hidden');
                    lastUserMessage = messages[messages.length - 2]?.content || null;
                } else {
                    regenerateButton.classList.add('hidden');
                    lastUserMessage = null;
                }
            } else {
                regenerateButton.classList.add('hidden');
                lastUserMessage = null;
            }
        }

        // Regenerate last LLM response
        async function regenerateResponse() {
            if (!currentChatId || !lastUserMessage || !modelSelect.value) return;

            // Remove last LLM response
            const histories = JSON.parse(localStorage.getItem('chatHistories') || '{}');
            const messages = histories[currentChatId].messages;
            if (messages[messages.length - 1].sender === 'Bot') {
                messages.pop();
                localStorage.setItem('chatHistories', JSON.stringify(histories));
                loadChatHistory(currentChatId);
            }

            // Resend last user message
            try {
                const systemPrompt = loadSystemPrompt();
                const messages = systemPrompt ? [{ role: 'system', content: systemPrompt }, { role: 'user', content: lastUserMessage }] : [{ role: 'user', content: lastUserMessage }];
                const response = await fetch(chatUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: modelSelect.value,
                        messages,
                        max_tokens: parseInt(maxTokensSelect.value),
                        top_p: parseFloat(topPSelect.value),
                        temperature: parseFloat(temperatureSelect.value),
                    }),
                });

                if (!response.ok) {
                    throw new Error(`Failed to fetch from ${chatUrl}: ${response.statusText}`);
                }

                const data = await response.json();
                const botMessage = data.choices[0].message.content;
                appendMessage('Bot', botMessage, 'text-gray-800');
            } catch (error) {
                appendMessage('Error', `Failed to regenerate response: ${error.message}`, 'text-red-600');
            }
        }

        async function sendMessage() {
            if (!currentChatId) {
                alert('Please start or select a chat history first.');
                return;
            }
            if (!modelSelect.value) {
                alert('Please select a model first.');
                return;
            }

            const message = userInput.value.trim();
            if (!message) return;

            // Display user message
            appendMessage('You', message, 'text-blue-600');
            userInput.value = '';

            try {
                const systemPrompt = loadSystemPrompt();
                const messages = systemPrompt ? [{ role: 'system', content: systemPrompt }, { role: 'user', content: message }] : [{ role: 'user', content: message }];
                const response = await fetch(chatUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: modelSelect.value,
                        messages,
                        max_tokens: parseInt(maxTokensSelect.value),
                        top_p: parseFloat(topPSelect.value),
                        temperature: parseFloat(temperatureSelect.value),
                    }),
                });

                if (!response.ok) {
                    throw new Error(`Failed to fetch from ${chatUrl}: ${response.statusText}`);
                }

                const data = await response.json();
                const botMessage = data.choices[0].message.content;
                appendMessage('Bot', botMessage, 'text-gray-800');
            } catch (error) {
                appendMessage('Error', `Failed to get response from LM Studio: ${error.message}`, 'text-red-600');
            }
        }

        // Event listeners
        chatHistorySelect.addEventListener('change', (e) => {
            if (e.target.value) {
                loadChatHistory(e.target.value);
            } else {
                currentChatId = null;
                chatContainer.innerHTML = '';
                regenerateButton.classList.add('hidden');
            }
        });

        newChatButton.addEventListener('click', startNewChat);
        renameChatButton.addEventListener('click', renameChat);
        forkChatButton.addEventListener('click', forkChat);
        deleteChatButton.addEventListener('click', deleteChatHistory);
        retryModelsButton.addEventListener('click', loadModels);
        saveUrlButton.addEventListener('click', updateApiUrls);
        setPromptButton.addEventListener('click', () => {
            systemPromptInput.value = loadSystemPrompt();
            promptModal.classList.remove('hidden');
        });
        seePromptButton.addEventListener('click', showSystemPrompt);
        savePromptButton.addEventListener('click', saveSystemPrompt);
        cancelPromptButton.addEventListener('click', () => promptModal.classList.add('hidden'));
        closePromptButton.addEventListener('click', () => seePromptModal.classList.add('hidden'));
        saveMessageButton.addEventListener('click', saveEditedMessage);
        cancelMessageButton.addEventListener('click', () => editMessageModal.classList.add('hidden'));
        regenerateButton.addEventListener('click', regenerateResponse);

        serverUrlInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                updateApiUrls();
            }
        });

        userInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        });

        // Initialize chat histories and models
        loadChatHistories();
        loadModels();
    </script>
</body>
</html>
